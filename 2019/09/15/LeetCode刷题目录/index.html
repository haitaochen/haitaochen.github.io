<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">

<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">








<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="链表1. 找出两个链表的交点12345678例如以下示例中 A 和 B 两个链表相交于 c1：​```htmlA:          a1 → a2                    ↘                      c1 → c2 → c3                    ↗B:    b1 → b2 → b3
输出那个ListNode c1">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode刷题目录">
<meta property="og:url" content="http://haitaochen.github.io/2019/09/15/LeetCode刷题目录/index.html">
<meta property="og:site_name" content="嗨嗨陶晨">
<meta property="og:description" content="链表1. 找出两个链表的交点12345678例如以下示例中 A 和 B 两个链表相交于 c1：​```htmlA:          a1 → a2                    ↘                      c1 → c2 → c3                    ↗B:    b1 → b2 → b3
输出那个ListNode c1">
<meta property="og:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png">
<meta property="og:image" content="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/7a3215ec-6fb7-4935-8b0d-cb408208f7cb.png">
<meta property="og:updated_time" content="2020-04-15T08:45:14.234Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LeetCode刷题目录">
<meta name="twitter:description" content="链表1. 找出两个链表的交点12345678例如以下示例中 A 和 B 两个链表相交于 c1：​```htmlA:          a1 → a2                    ↘                      c1 → c2 → c3                    ↗B:    b1 → b2 → b3
输出那个ListNode c1">
<meta name="twitter:image" content="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://haitaochen.github.io/2019/09/15/LeetCode刷题目录/"/>





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "f2e85671"
    });
  daovoice('update');
  </script>


  <title>LeetCode刷题目录 | 嗨嗨陶晨</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband">
      <a href="https://github.com/haitaochen" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">嗨嗨陶晨</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://haitaochen.github.io/2019/09/15/LeetCode刷题目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈海涛">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/14857317?s=460&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="嗨嗨陶晨">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">LeetCode刷题目录</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-15T16:09:01+08:00">
                2019-09-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  10,885
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  43分钟
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="1-找出两个链表的交点"><a href="#1-找出两个链表的交点" class="headerlink" title="1. 找出两个链表的交点"></a>1. 找出两个链表的交点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">例如以下示例中 A 和 B 两个链表相交于 c1：</div><div class="line"></div><div class="line">​```html</div><div class="line">A:          a1 → a2</div><div class="line">                    ↘</div><div class="line">                      c1 → c2 → c3</div><div class="line">                    ↗</div><div class="line">B:    b1 → b2 → b3</div></pre></td></tr></table></figure>
<p>输出那个ListNode c1<br><a id="more"></a><br>思路：合并成一个相同链表考虑。</p>
<p>设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">如果只是判断是否存在交点，那么就是另一个问题，即 [编程之美 3.6]() 的问题。有两种解法：</div><div class="line"></div><div class="line">- 把第一个链表的结尾连接到第二个链表的开头，看第二个链表是否存在环；</div><div class="line">- 或者直接比较两个链表的最后一个节点是否相同。</div></pre></td></tr></table></figure>
<h4 id="2-链表反转"><a href="#2-链表反转" class="headerlink" title="2. 链表反转"></a>2. 链表反转</h4><p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</div><div class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</div></pre></td></tr></table></figure>
<p>思路：递归/头插法</p>
<h4 id="3-归并两个有序的链表"><a href="#3-归并两个有序的链表" class="headerlink" title="3. 归并两个有序的链表"></a>3. 归并两个有序的链表</h4><p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</div><div class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</div></pre></td></tr></table></figure>
<p>思路：递归（递归出口不太好想）/迭代</p>
<h4 id="4-从有序链表中删除重复节点"><a href="#4-从有序链表中删除重复节点" class="headerlink" title="4. 从有序链表中删除重复节点"></a>4. 从有序链表中删除重复节点</h4><p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: 1-&gt;1-&gt;2</div><div class="line">输出: 1-&gt;2</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: 1-&gt;1-&gt;2-&gt;3-&gt;3</div><div class="line">输出: 1-&gt;2-&gt;3</div></pre></td></tr></table></figure>
<p>思路：1直接法2（比较前后值）尾插法3递归（注意递归出口）</p>
<h4 id="5-删除链表的倒数第-n-个节点"><a href="#5-删除链表的倒数第-n-个节点" class="headerlink" title="5. 删除链表的倒数第 n 个节点"></a>5. 删除链表的倒数第 n 个节点</h4><p><strong>示例：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</div><div class="line"></div><div class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</div></pre></td></tr></table></figure>
<p><strong>进阶：</strong></p>
<p>你能尝试使用一趟扫描实现吗？</p>
<p>思路：1两趟很容易想到2一趟用双指针（指针保持n距离往后移到null）</p>
<h4 id="6-交换链表中的相邻结点"><a href="#6-交换链表中的相邻结点" class="headerlink" title="6. 交换链表中的相邻结点"></a>6. 交换链表中的相邻结点</h4><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<p>示例:</p>
<p>给定 1-&gt;2-&gt;3-&gt;4, 你应该返回 2-&gt;1-&gt;4-&gt;3.</p>
<p>思路：就常规思路。</p>
<h4 id="7-链表求和"><a href="#7-链表求和" class="headerlink" title="7. 链表求和"></a>7. 链表求和</h4><p>进阶:</p>
<p>如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</p>
<p>示例:</p>
<p>输入: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出: 7 -&gt; 8 -&gt; 0 -&gt; 7</p>
<p>思路：1用到翻转2用栈做two sum 进位相加</p>
<h4 id="8-回文链表"><a href="#8-回文链表" class="headerlink" title="8. 回文链表"></a>8. 回文链表</h4><p>请判断一个链表是否为回文链表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: 1-&gt;2</div><div class="line">输出: false</div></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: 1-&gt;2-&gt;2-&gt;1</div><div class="line">输出: true</div></pre></td></tr></table></figure>
<p>思路：</p>
<p>切成两半【用fast slow 找出中间的节点】（如果不切，想把整个串反转再比较 不行 会破坏链表结构），把后半段反转，然后比较两半是否相等。</p>
<h4 id="9-分隔链表"><a href="#9-分隔链表" class="headerlink" title="9. 分隔链表"></a>9. 分隔链表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">root = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], k = 3</div><div class="line">Output: [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]</div><div class="line"></div><div class="line">输入: </div><div class="line">root = [1, 2, 3], k = 5</div><div class="line">输出: [[1],[2],[3],[],[]]</div></pre></td></tr></table></figure>
<p>思路：就运用链表，分成几份，把最后的next置成null</p>
<h4 id="10-链表元素按奇偶聚集"><a href="#10-链表元素按奇偶聚集" class="headerlink" title="10. 链表元素按奇偶聚集"></a>10. 链表元素按奇偶聚集</h4><p>请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p>
<p><strong>Example 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</div><div class="line">Output: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</div></pre></td></tr></table></figure>
<p><strong>Example 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL</div><div class="line">Output: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</div></pre></td></tr></table></figure>
<p>思路：用链表，3个指针，注意while条件</p>
<blockquote>
<p>总结：有不少题目可以用递归解体，但要注意出口条件（2,3,4）；题设参数给出的链表往往第一个节点就是值节点，我们编代码时可以加上一个头结点方便理解；尾插法会移动头结点位置，头插法不会，但是头插法需要记住上一个新增的节点位置；某些时候可以把新增一个链表作为思路（头/尾插法）；注意双指针，栈等数据结构使用</p>
</blockquote>
<h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="1-有序数组的-Two-Sum"><a href="#1-有序数组的-Two-Sum" class="headerlink" title="1. 有序数组的 Two Sum"></a>1. 有序数组的 Two Sum</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: numbers=&#123;2, 7, 11, 15&#125;, target=9</div><div class="line">Output: index1=1, index2=2</div></pre></td></tr></table></figure>
<p>题目描述：在有序数组中找出两个数，使它们的和为 target。</p>
<p>思路：双指针，一头一尾。</p>
<h4 id="2-两数平方和"><a href="#2-两数平方和" class="headerlink" title="2. 两数平方和"></a>2. 两数平方和</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: 5</div><div class="line">Output: True</div><div class="line">Explanation: 1 * 1 + 2 * 2 = 5</div></pre></td></tr></table></figure>
<p>题目描述：判断一个数是否为两个数的平方和。</p>
<p>思路：双指针，一头一尾（尾指向开方位置即可）。</p>
<h4 id="3-反转字符串中的元音字符"><a href="#3-反转字符串中的元音字符" class="headerlink" title="3. 反转字符串中的元音字符"></a>3. 反转字符串中的元音字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Given s = &quot;leetcode&quot;, return &quot;leotcede&quot;.</div></pre></td></tr></table></figure>
<p>思路：双指针，一头一尾，注意if 分支书写。</p>
<h4 id="4-回文字符串"><a href="#4-回文字符串" class="headerlink" title="4. 回文字符串"></a>4. 回文字符串</h4><p>示例 1:</p>
<p>输入: “aba”<br>输出: True<br>示例 2:</p>
<p>输入: “abca”<br>输出: True<br>解释: 你可以删除c字符。<br>注意:</p>
<p>字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。</p>
<p>思路：首尾指针，首尾端字母不等式，选其中一端删除字母后比较剩余字符串是否为回文串（思路比较自然，好想）</p>
<h4 id="5-归并两个有序数组"><a href="#5-归并两个有序数组" class="headerlink" title="5. 归并两个有序数组"></a>5. 归并两个有序数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">nums1 = [1,2,3,0,0,0], m = 3</div><div class="line">nums2 = [2,5,6],       n = 3</div><div class="line"></div><div class="line">Output: [1,2,2,3,5,6]</div></pre></td></tr></table></figure>
<p>题目描述：把归并结果存到第一个数组上。</p>
<p>思路：双指针（均指向尾部），从尾向头可以省去额外空间，注意if分支；</p>
<h4 id="6-判断链表是否存在环"><a href="#6-判断链表是否存在环" class="headerlink" title="6. 判断链表是否存在环"></a>6. 判断链表是否存在环</h4><p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入：head = [3,2,0,-4], pos = 1</div><div class="line">输出：true</div><div class="line">解释：链表中有一个环，其尾部连接到第二个节点。</div></pre></td></tr></table></figure>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png" alt="img"></p>
<p>思路：</p>
<p>使用双指针，一个指针每次移动一个节点，一个指针每次移动两个节点，如果存在环，那么这两个指针一定会相遇。</p>
<h4 id="7-最长子序列"><a href="#7-最长子序列" class="headerlink" title="7. 最长子序列"></a>7. 最长子序列</h4><p>给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符串。如果答案不存在，则返回空字符串。</p>
<p>示例 1:</p>
<p>输入:<br>s = “abpcplea”, d = [“ale”,”apple”,”monkey”,”plea”]</p>
<p>输出:<br>“apple”</p>
<p>思路：双指针首先还是比较好想到，但在循环中更巧妙地筛选出字典序和长度条件不符的字符串 不太好想</p>
<h3 id="数组与矩阵"><a href="#数组与矩阵" class="headerlink" title="数组与矩阵"></a>数组与矩阵</h3><h4 id="1-把数组中的-0-移到末尾"><a href="#1-把数组中的-0-移到末尾" class="headerlink" title="1. 把数组中的 0 移到末尾"></a>1. 把数组中的 0 移到末尾</h4><p>给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
<p>示例:</p>
<p>输入: [0,1,0,3,12]<br>输出: [1,3,12,0,0]<br>说明:</p>
<p>必须在原数组上操作，不能拷贝额外的数组。<br>尽量减少操作次数。</p>
<p>思路：1o(n)解法2o(n方)解法（我用的交换）。</p>
<h4 id="2-改变矩阵维度"><a href="#2-改变矩阵维度" class="headerlink" title="2. 改变矩阵维度"></a>2. 改变矩阵维度</h4><p>给出一个由二维数组表示的矩阵，以及两个正整数<code>r</code>和<code>c</code>，分别表示想要的重构的矩阵的行数和列数。</p>
<p>重构后的矩阵需要将原始矩阵的所有元素以相同的<strong>行遍历顺序</strong>填充。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">输入: </div><div class="line">nums = </div><div class="line">[[1,2],</div><div class="line"> [3,4]]</div><div class="line">r = 1, c = 4</div><div class="line">输出: </div><div class="line">[[1,2,3,4]]</div><div class="line">解释:</div><div class="line">行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。</div><div class="line"></div><div class="line"></div><div class="line">输入: </div><div class="line">nums = </div><div class="line">[[1,2],</div><div class="line"> [3,4]]</div><div class="line">r = 2, c = 4</div><div class="line">输出: </div><div class="line">[[1,2],</div><div class="line"> [3,4]]</div><div class="line"> 解释:</div><div class="line">没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。</div></pre></td></tr></table></figure>
<p>思路：循环遍历。</p>
<h4 id="3-找出数组中最长的连续-1"><a href="#3-找出数组中最长的连续-1" class="headerlink" title="3. 找出数组中最长的连续 1"></a>3. 找出数组中最长的连续 1</h4><p>给定一个二进制数组， 计算其中最大连续1的个数。</p>
<p>示例 1:</p>
<p>输入: [1,1,0,1,1,1]<br>输出: 3<br>解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.</p>
<p>思路：正常想。</p>
<h4 id="4-有序矩阵查找"><a href="#4-有序矩阵查找" class="headerlink" title="4. 有序矩阵查找"></a>4. 有序矩阵查找</h4><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target。该矩阵具有以下特性：</p>
<p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。<br>示例:</p>
<p>现有矩阵 matrix 如下：</p>
<p>[<br>  [1,   4,  7, 11, 15],<br>  [2,   5,  8, 12, 19],<br>  [3,   6,  9, 16, 22],<br>  [10, 13, 14, 17, 24],<br>  [18, 21, 23, 26, 30]<br>]<br>给定 target = 5，返回 true。</p>
<p>给定 target = 20，返回 false。</p>
<p>思路：1递归（我的解法）2正常循环遍历（GitHub解法）row=0,col=列数-1，target小row++,target大col–;</p>
<h4 id="5-有序矩阵的-Kth-Element"><a href="#5-有序矩阵的-Kth-Element" class="headerlink" title="5. 有序矩阵的 Kth Element"></a>5. 有序矩阵的 Kth Element</h4><p>给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第k小的元素。<br>请注意，它是排序后的第k小元素，而不是第k个元素。</p>
<p>示例:</p>
<p>matrix = [<br>   [ 1,  5,  9],<br>   [10, 11, 13],<br>   [12, 13, 15]<br>],<br>k = 8,</p>
<p>返回 13。</p>
<p>思路：1二分查找（GitHub解法）2堆解法：a.小顶堆里面放n*n个元素，删除k-1个元素，剩下来的堆顶元素即为所找。（GitHub解法）b.往小顶堆中不断追加matrix里的元素，追加过程中维护堆的大小保证为matrix.length+1-k，追加完成后，堆顶元素即为所找。（我的解法）</p>
<blockquote>
<p>小顶堆Java定义写法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(); <span class="comment">// 小顶堆</span></div></pre></td></tr></table></figure>
<h4 id="6-一个数组元素在-1-n-之间，其中一个数被替换为另一个数，找出重复的数和丢失的数"><a href="#6-一个数组元素在-1-n-之间，其中一个数被替换为另一个数，找出重复的数和丢失的数" class="headerlink" title="6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数"></a>6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</h4><p>集合 S 包含从1到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个元素复制了成了集合里面的另外一个元素的值，导致集合丢失了一个整数并且有一个元素重复。</p>
<p>给定一个数组 nums 代表了集合 S 发生错误后的结果。你的任务是首先寻找到重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p>
<p>示例 1:</p>
<p>输入: nums = [1,2,2,4]<br>输出: [2,3]<br>注意:</p>
<p>给定数组的长度范围是 [2, 10000]。<br>给定的数组是无序的。</p>
<p>思路：1.排序后找到（时：o(logN)）2用一个数组记录数字出现一次还是2次还是0次（时：o(N);空：o(Log(N))）【我的解法】3.利用交换实现时：o(N),空间o(1)</p>
<h4 id="6-1寻找所有丢失的元素"><a href="#6-1寻找所有丢失的元素" class="headerlink" title="6.1寻找所有丢失的元素"></a>6.1寻找所有丢失的元素</h4><p>给定一个范围在  1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</p>
<p>找到所有在 [1, n] 范围之间没有出现在数组中的数字。</p>
<p>您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</p>
<p>示例:</p>
<p>输入:<br>[4,3,2,7,8,2,3,1]</p>
<p>输出:<br>[5,6]</p>
<p>思路：同上面的交换解法</p>
<h4 id="6-2寻找所有重复的元素-同上思路"><a href="#6-2寻找所有重复的元素-同上思路" class="headerlink" title="6.2寻找所有重复的元素(同上思路)"></a>6.2寻找所有重复的元素(同上思路)</h4><h4 id="7-找出数组中重复的数，数组值在-1-n-之间"><a href="#7-找出数组中重复的数，数组值在-1-n-之间" class="headerlink" title="7. 找出数组中重复的数，数组值在 [1, n] 之间"></a>7. 找出数组中重复的数，数组值在 [1, n] 之间</h4><p>给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</p>
<p>示例 1:</p>
<p>输入: [1,3,4,2,2]<br>输出: 2<br>示例 2:</p>
<p>输入: [3,1,3,4,2]<br>输出: 3<br>说明：</p>
<p>不能更改原数组（假设数组是只读的）。<br>只能使用额外的 O(1) 的空间。<br>时间复杂度小于 O(n2) 。<br>数组中只有一个重复的数字，但它可能不止重复出现一次。</p>
<p>思路：1二分2双指针快慢（类似于有环链表中找出环的入口）参考LeetCode官方解法以及下方评论</p>
<h4 id="8-数组相邻差值的个数"><a href="#8-数组相邻差值的个数" class="headerlink" title="8. 数组相邻差值的个数"></a>8. 数组相邻差值的个数</h4><p>给定两个整数 n 和 k，你需要实现一个数组，这个数组包含从 1 到 n 的 n 个不同整数，同时满足以下条件：</p>
<p>① 如果这个数组是 [a1, a2, a3, … , an] ，那么数组 [|a1 - a2|, |a2 - a3|, |a3 - a4|, … , |an-1 - an|] 中应该有且仅有 k 个不同整数；.</p>
<p>② 如果存在多种答案，你只需实现并返回其中任意一种.</p>
<p>示例 1:</p>
<p>输入: n = 3, k = 1<br>输出: [1, 2, 3]<br>解释: [1, 2, 3] 包含 3 个范围在 1-3 的不同整数， 并且 [1, 1] 中有且仅有 1 个不同整数 : 1</p>
<p>示例 2:</p>
<p>输入: n = 3, k = 2<br>输出: [1, 3, 2]<br>解释: [1, 3, 2] 包含 3 个范围在 1-3 的不同整数， 并且 [2, 1] 中有且仅有 2 个不同整数: 1 和 2</p>
<p>思路：让前 k+1 个元素构建出 k 个不相同的差值，序列为：1 k+1 2 k 3 k-1 … k/2 k/2+1.</p>
<h4 id="9-数组的度"><a href="#9-数组的度" class="headerlink" title="9. 数组的度"></a>9. 数组的度</h4><p>给定一个非空且只包含非负数的整数数组 nums, 数组的度的定义是指数组里任一元素出现频数的最大值。</p>
<p>你的任务是找到与 nums 拥有相同大小的度的最短连续子数组，返回其长度。</p>
<p>示例 1:</p>
<p>输入: [1, 2, 2, 3, 1]<br>输出: 2<br>解释:<br>输入数组的度是2，因为元素1和2的出现频数最大，均为2.<br>连续子数组里面拥有相同度的有如下所示:<br>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]<br>最短连续子数组[2, 2]的长度为2，所以返回2.<br>示例 2:</p>
<p>输入: [1,2,2,3,1,4,2]<br>输出: 6</p>
<p>思路：1一步一步做（我的解法）2GitHub解法代码更简洁</p>
<h4 id="10-对角元素相等的矩阵"><a href="#10-对角元素相等的矩阵" class="headerlink" title="10. 对角元素相等的矩阵"></a>10. 对角元素相等的矩阵</h4><p>如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。</p>
<p>给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">输入: </div><div class="line">matrix = [</div><div class="line">  [1,2,3,4],</div><div class="line">  [5,1,2,3],</div><div class="line">  [9,5,1,2]</div><div class="line">]</div><div class="line">输出: True</div></pre></td></tr></table></figure>
<p>思路：1自己思路ac 不了2GitHub思路：用一个递归的check方法，递归出口–超出边界—返回true</p>
<h4 id="11-嵌套数组"><a href="#11-嵌套数组" class="headerlink" title="11. 嵌套数组"></a>11. 嵌套数组</h4><p>索引从0开始长度为N的数组A，包含0到N - 1的所有整数。找到并返回最大的集合S，S[i] = {A[i], A[A[i]], A[A[A[i]]], … }且遵守以下的规则。</p>
<p>假设选择索引为i的元素A[i]为S的第一个元素，S的下一个元素应该是A[A[i]]，之后是A[A[A[i]]]… 以此类推，不断添加直到S出现重复的元素。</p>
<p>输入: A = [5,4,0,3,1,6,2]<br>输出: 4<br>解释:<br>A[0] = 5, A[1] = 4, A[2] = 0, A[3] = 3, A[4] = 1, A[5] = 6, A[6] = 2.</p>
<p>其中一种最长的 S[K]:<br>S[0] = {A[0], A[5], A[6], A[2]} = {5, 6, 2, 0}</p>
<p>思路：1我的思路有点类似递归加记忆化搜索2GitHub解法用2层循环，第二层循环访问过就标记-1，当再次遇到-1即形成环此时退出循环。</p>
<h4 id="12-分隔数组"><a href="#12-分隔数组" class="headerlink" title="12. 分隔数组"></a>12. 分隔数组</h4><p>数组arr是[0, 1, …, arr.length - 1]的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。</p>
<p>我们最多能将数组分成多少块？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">输入: arr = [4,3,2,1,0]</div><div class="line">输出: 1</div><div class="line"></div><div class="line">输入: arr = [1,0,2,3,4]</div><div class="line">输出: 4</div></pre></td></tr></table></figure>
<p>思路：1我的解法：设置两个sum分别累加索引和值，2个sum相等时，cnt++同时2个sum归0；2github解法：找到当前段最大值right，right==索引 cnt才++。</p>
<blockquote>
<p>总结：对于矩阵可以想到递归解决（10），对于特殊矩阵注意遍历顺序（4）；数组如要找出重复数或丢失数可考虑用到交换（6,7）；注意一些类似递归搜索的想法（11）；注意arr[i]和i的关系（12）</p>
</blockquote>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="1-字符串循环移位包含"><a href="#1-字符串循环移位包含" class="headerlink" title="1. 字符串循环移位包含"></a>1. 字符串循环移位包含</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s1 = AABCD, s2 = CDAA</div><div class="line">Return : true</div></pre></td></tr></table></figure>
<p>给定两个字符串 s1 和 s2，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含。</p>
<p>s1 进行循环移位的结果是 s1s1 的子字符串，因此只要判断 s2 是否是 s1s1 的子字符串即可。</p>
<h4 id="2-字符串循环移位"><a href="#2-字符串循环移位" class="headerlink" title="2. 字符串循环移位"></a>2. 字符串循环移位</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = &quot;abcd123&quot; k = 3</div><div class="line">Return &quot;123abcd&quot;</div></pre></td></tr></table></figure>
<p>将字符串向右循环移动 k 位。</p>
<p>将 abcd123 中的 abcd 和 123 单独翻转，得到 dcba321，然后对整个字符串进行翻转，得到 123abcd。</p>
<h4 id="3-字符串中单词的翻转"><a href="#3-字符串中单词的翻转" class="headerlink" title="3. 字符串中单词的翻转"></a>3. 字符串中单词的翻转</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">s = &quot;I am a student&quot;</div><div class="line">Return &quot;student a am I&quot;</div></pre></td></tr></table></figure>
<p>将每个单词翻转，然后将整个字符串翻转。</p>
<h4 id="4-两个字符串包含的字符是否完全相同"><a href="#4-两个字符串包含的字符是否完全相同" class="headerlink" title="4. 两个字符串包含的字符是否完全相同"></a>4. 两个字符串包含的字符是否完全相同</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">s = &quot;anagram&quot;, t = &quot;nagaram&quot;, return true.</div><div class="line">s = &quot;rat&quot;, t = &quot;car&quot;, return false.</div><div class="line"></div><div class="line">字母异位词是指由相同的字母按照不同的顺序组成的单词</div></pre></td></tr></table></figure>
<p>思路：用一个空间；桶（需要统计每个字母出现次数）</p>
<h4 id="5-计算一组字符集合可以组成的回文字符串的最大长度"><a href="#5-计算一组字符集合可以组成的回文字符串的最大长度" class="headerlink" title="5. 计算一组字符集合可以组成的回文字符串的最大长度"></a>5. 计算一组字符集合可以组成的回文字符串的最大长度</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input : &quot;abccccdd&quot;</div><div class="line">Output : 7</div><div class="line">Explanation : One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7.</div></pre></td></tr></table></figure>
<p>思路：GitHub解法用 (cnt/2)*2；桶（需要统计每个字母出现次数）</p>
<h4 id="6-字符串同构"><a href="#6-字符串同构" class="headerlink" title="6. 字符串同构"></a>6. 字符串同构</h4><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p>
<p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p>
<p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">输入: s = &quot;egg&quot;, t = &quot;add&quot;</div><div class="line">输出: true</div><div class="line"></div><div class="line">输入: s = &quot;foo&quot;, t = &quot;bar&quot;</div><div class="line">输出: false</div></pre></td></tr></table></figure>
<p>思路：（<strong>标记一下</strong> ）</p>
<p>记录一个字符上次出现的位置，如果两个字符串中的字符上次出现的位置一样，那么就属于同构。</p>
<h4 id="7-回文子字符串个数"><a href="#7-回文子字符串个数" class="headerlink" title="7. 回文子字符串个数"></a>7. 回文子字符串个数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Input: &quot;aaa&quot;</div><div class="line">Output: 6</div><div class="line">Explanation: Six palindromic strings: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;.</div></pre></td></tr></table></figure>
<p>思路：中心扩展。（<strong>标记一下，容易忘</strong>）</p>
<h4 id="8-判断一个整数是否是回文数"><a href="#8-判断一个整数是否是回文数" class="headerlink" title="8. 判断一个整数是否是回文数"></a>8. 判断一个整数是否是回文数</h4><p>要求不能使用额外空间，也就不能将整数转换为字符串进行判断。</p>
<p>思路：GitHub解法（将整数分成左右两部分，右边那部分需要转置，然后判断这两部分是否相等）</p>
<h4 id="9-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数"><a href="#9-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数" class="headerlink" title="9. 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数"></a>9. 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数</h4><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p>
<p>重复出现的子串要计算它们出现的次数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: &quot;00110011&quot;</div><div class="line">输出: 6</div><div class="line">解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。</div></pre></td></tr></table></figure>
<p>思路：<strong>标记一下</strong></p>
<p>First, I count the number of 1 or 0 grouped consecutively.<br>For example “0110001111” will be <code>[1, 2, 3, 4]</code>.</p>
<p>Second, for any possible substrings with 1 and 0 grouped consecutively, the number of valid substring will be the minimum number of 0 and 1.<br>For example “0001111”, will be <code>min(3, 4) = 3</code>, (<code>&quot;01&quot;, &quot;0011&quot;, &quot;000111&quot;</code>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">       <span class="keyword">int</span> cur = <span class="number">1</span>, pre = <span class="number">0</span>, res = <span class="number">0</span>;</div><div class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</div><div class="line">           <span class="keyword">if</span> (s.charAt(i) == s.charAt(i - <span class="number">1</span>)) cur++;</div><div class="line">           <span class="keyword">else</span> &#123;</div><div class="line">               res += Math.min(cur, pre);</div><div class="line">               pre = cur;</div><div class="line">               cur = <span class="number">1</span>;</div><div class="line">           &#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> res + Math.min(cur, pre);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="1-数组中两个数的和为给定值"><a href="#1-数组中两个数的和为给定值" class="headerlink" title="1. 数组中两个数的和为给定值"></a>1. 数组中两个数的和为给定值</h4><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p>
<p>示例:</p>
<p>给定 nums = [2, 7, 11, 15], target = 9</p>
<p>因为 nums[0] + nums[1] = 2 + 7 = 9<br>所以返回 [0, 1]</p>
<p>思路：1暴力2两遍哈希表3一遍哈希表</p>
<h4 id="2-判断数组是否含有重复元素"><a href="#2-判断数组是否含有重复元素" class="headerlink" title="2. 判断数组是否含有重复元素"></a>2. 判断数组是否含有重复元素</h4><p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。</p>
<p>示例 1:</p>
<p>输入: [1,2,3,1]<br>输出: true</p>
<p>思路：1hashmap 2hashset（巧妙利用长度比较）</p>
<h4 id="3-最长和谐序列"><a href="#3-最长和谐序列" class="headerlink" title="3. 最长和谐序列"></a>3. 最长和谐序列</h4><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别正好是1。</p>
<p>现在，给定一个整数数组，你需要在所有可能的子序列中找到最长的和谐子序列的长度。</p>
<p>示例 1:</p>
<p>输入: [1,3,2,2,5,2,3,7]<br>输出: 5<br>原因: 最长的和谐数组是：[3,2,2,2,3].</p>
<p>思路：hash表，遍历时只需要找有没有大一的就好，小一的不用考虑；因为后续遍历过程中还是能访问到。</p>
<h4 id="4-最长连续序列"><a href="#4-最长连续序列" class="headerlink" title="4. 最长连续序列"></a>4. 最长连续序列</h4><p><strong>没做出来</strong></p>
<p>（今天用排序方法做出来）</p>
<p>给定一个未排序的整数数组，找出最长连续序列的长度。</p>
<p>要求算法的时间复杂度为 O(n)。</p>
<p>示例:</p>
<p>输入: [100, 4, 200, 1, 3, 2]<br>输出: 4<br>解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。</p>
<p>思路：1 排序后再找（我的解法）2hashset 只找比当前数大一的不找小一的；</p>
<blockquote>
<p>哈希表这种空间换时间的算法有时候不太好想；桶排序；通常对调k v 去建立哈希表；hashmap,hashset;遍历过程往往只需找大一，小一的情况在后遍历过程中还是能访问到，不会出现考虑不全面的问题。</p>
</blockquote>
<h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a><strong>栈和队列</strong></h3><h4 id="1-用栈实现队列"><a href="#1-用栈实现队列" class="headerlink" title="1. 用栈实现队列"></a>1. 用栈实现队列</h4><p>思路：</p>
<p>栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。</p>
<h4 id="2-用队列实现栈"><a href="#2-用队列实现栈" class="headerlink" title="2. 用队列实现栈"></a>2. 用队列实现栈</h4><p>思路：</p>
<p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。【这个容易忘】</p>
<h4 id="3-最小值栈"><a href="#3-最小值栈" class="headerlink" title="3. 最小值栈"></a>3. 最小值栈</h4><p>思路：维护一个data栈，和一个最小值栈（且data栈push时它也push，data栈pop时它也pop）；</p>
<p>对于实现最小值队列问题，可以先将队列使用栈来实现，然后就将问题转换为最小值栈，这个问题出现在 编程之美：3.7。（我的解法是用一个栈存data，在pop的时候花o(n)的时间去遍历得到最小值）</p>
<h4 id="4-用栈实现括号匹配"><a href="#4-用栈实现括号匹配" class="headerlink" title="4.用栈实现括号匹配"></a>4.用栈实现括号匹配</h4><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p>
<p>有效字符串需满足：</p>
<p>左括号必须用相同类型的右括号闭合。<br>左括号必须以正确的顺序闭合。<br>注意空字符串可被认为是有效字符串。</p>
<p>示例 1:</p>
<p>输入: “()”<br>输出: true</p>
<p><strong>示例 3:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">输入: &quot;(]&quot;</div><div class="line">输出: false</div></pre></td></tr></table></figure>
<p>思路：判断是左括号时进栈，否则先出栈比较是否匹配，匹配则进栈，不匹配直接return false。</p>
<h4 id="5-数组中元素与下一个比它大的元素之间的距离"><a href="#5-数组中元素与下一个比它大的元素之间的距离" class="headerlink" title="5. 数组中元素与下一个比它大的元素之间的距离"></a>5. 数组中元素与下一个比它大的元素之间的距离</h4><p>思路：</p>
<p>在遍历数组时用栈把数组中的数存起来，如果当前遍历的数比栈顶元素来的大，说明栈顶元素的下一个比它大的数就是当前元素。（巧妙地用数组的索引的差值来计算出距离，栈里面仅保存索引，值可以用数组获取到）（我的解法是走2层循环用双指针）</p>
<h4 id="6-循环数组中比当前元素大的下一个元素"><a href="#6-循环数组中比当前元素大的下一个元素" class="headerlink" title="6. 循环数组中比当前元素大的下一个元素"></a>6. 循环数组中比当前元素大的下一个元素</h4><p>思路：</p>
<p>与 上题不同的是，数组是循环数组，并且最后要求的不是距离而是下一个元素。（一样做）</p>
<blockquote>
<p>用队列实现栈记得是push的时候把所有其他元素出队;最小值栈注意minstack长度使他和数据栈长度一样来处理；5，6记得栈里面存索引</p>
</blockquote>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="1-Kth-Element"><a href="#1-Kth-Element" class="headerlink" title="1. Kth Element"></a>1. Kth Element</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [3,2,1,5,6,4] and k = 2</div><div class="line">Output: 5</div></pre></td></tr></table></figure>
<p>题目描述：找到倒数第 k 个的元素。</p>
<p><strong>排序</strong> ：时间复杂度 O(NlogN)，空间复杂度 O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    Arrays.sort(nums);</div><div class="line">    <span class="keyword">return</span> nums[nums.length - k];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>堆</strong> ：时间复杂度 O(NlogK)，空间复杂度 O(K)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">    PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;(); <span class="comment">// 小顶堆</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> val : nums) &#123;</div><div class="line">        pq.add(val);</div><div class="line">        <span class="keyword">if</span> (pq.size() &gt; k)  <span class="comment">// 维护堆的大小为 K</span></div><div class="line">            pq.poll();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pq.peek();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>快速选择</strong> ：时间复杂度 O(N)，空间复杂度 O(1)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</div><div class="line">        k = nums.length - k;</div><div class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,h=nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (l&lt;h)&#123;</div><div class="line">            <span class="keyword">int</span> i = getPartition(l,h,nums);</div><div class="line">            <span class="keyword">if</span>(i==k)</div><div class="line">                <span class="keyword">return</span> nums[k];</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i&lt;k)</div><div class="line">                l = i+<span class="number">1</span>;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                h = i-<span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> nums[k];</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getPartition</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> h,<span class="keyword">int</span>[] nums)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> temp = nums[l];</div><div class="line">        <span class="keyword">while</span> (l&lt;h)&#123;</div><div class="line">            <span class="keyword">while</span> (l&lt;h&amp;&amp;nums[h]&gt;=temp)</div><div class="line">                h--;</div><div class="line">            nums[l]  = nums[h];</div><div class="line">            <span class="keyword">while</span> (l&lt;h&amp;&amp;nums[l]&lt;=temp)</div><div class="line">                l++;</div><div class="line">            nums[h] = nums[l];</div><div class="line">        &#125;</div><div class="line">        nums[l] = temp;</div><div class="line">        <span class="keyword">return</span> l;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h4><h4 id="1-出现频率最多的-k-个元素"><a href="#1-出现频率最多的-k-个元素" class="headerlink" title="1. 出现频率最多的 k 个元素"></a>1. 出现频率最多的 k 个元素</h4><p><a href="https://leetcode.com/problems/top-k-frequent-elements/description/" target="_blank" rel="external">347. Top K Frequent Elements (Medium)</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Given [1,1,1,2,2,3] and k = 2, return [1,2].</div></pre></td></tr></table></figure>
<p>设置若干个桶，每个桶存储出现频率相同的数。桶的下标表示数出现的频率，即第 i 个桶中存储的数出现的频率为 i。</p>
<p>把数都放到桶之后，从后向前遍历桶，最先得到的 k 个数就是出现频率最多的的 k 个数。</p>
<h4 id="2-按照字符出现次数对字符串排序"><a href="#2-按照字符出现次数对字符串排序" class="headerlink" title="2. 按照字符出现次数对字符串排序"></a>2. 按照字符出现次数对字符串排序</h4><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p>
<p>示例 1:</p>
<p>输入:<br>“tree”</p>
<p>输出:<br>“eert”</p>
<p>解释:<br>‘e’出现两次，’r’和’t’都只出现一次。<br>因此’e’必须出现在’r’和’t’之前。此外，”eetr”也是一个有效的答案。<br>示例 2:</p>
<p>输入:<br>“cccaaa”</p>
<p>输出:<br>“cccaaa”</p>
<p>解释:<br>‘c’和’a’都出现三次。此外，”aaaccc”也是有效的答案。<br>注意”cacaca”是不正确的，因为相同的字母必须放在一起。<br>示例 3:</p>
<p>输入:<br>“Aabb”</p>
<p>输出:<br>“bbAa”</p>
<p>解释:<br>此外，”bbaA”也是一个有效的答案，但”Aabb”是不正确的。<br>注意’A’和’a’被认为是两种不同的字符。</p>
<h4 id="荷兰国旗问题"><a href="#荷兰国旗问题" class="headerlink" title="荷兰国旗问题"></a>荷兰国旗问题</h4><p>荷兰国旗包含三种颜色：红、白、蓝。</p>
<p>有三种颜色的球，算法的目标是将这三种球按颜色顺序正确地排列。它其实是三向切分快速排序的一种变种，在三向切分快速排序中，每次切分都将数组分成三个区间：小于切分元素、等于切分元素、大于切分元素，而该算法是将数组分成三个区间：等于红色、等于白色、等于蓝色。</p>
<p><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/pics/7a3215ec-6fb7-4935-8b0d-cb408208f7cb.png" target="_blank" rel="external"><img src="https://github.com/CyC2018/CS-Notes/raw/master/notes/pics/7a3215ec-6fb7-4935-8b0d-cb408208f7cb.png" alt="img"></a></p>
<p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p>
<p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p>
<p>注意:<br>不能使用代码库中的排序函数来解决这道题。</p>
<p>示例:</p>
<p>输入: [2,0,2,1,1,0]<br>输出: [0,0,1,1,2,2]</p>
<p>思路：</p>
<p>我们用三个指针（p0, p2 和curr）来分别追踪0的最右边界，2的最左边界和当前考虑的元素。(容易忘)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> p0=<span class="number">0</span>,cur=<span class="number">0</span>,p2=nums.length-<span class="number">1</span>;</div><div class="line">        <span class="keyword">while</span> (cur&lt;=p2)&#123;</div><div class="line">            <span class="keyword">if</span>(nums[cur]==<span class="number">0</span>)</div><div class="line">                swap(nums,p0++,cur++);</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[cur]==<span class="number">2</span>)</div><div class="line">                swap(nums,cur,p2--);</div><div class="line">            <span class="keyword">else</span></div><div class="line">                cur++;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> t = nums[i];</div><div class="line">        nums[i] = nums[j];</div><div class="line">        nums[j] = t;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a><strong>二分查找</strong></h3><h4 id="1-求开方"><a href="#1-求开方" class="headerlink" title="1. 求开方"></a>1. 求开方</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Input: 4</div><div class="line">Output: 2</div><div class="line"></div><div class="line">Input: 8</div><div class="line">Output: 2</div><div class="line">Explanation: The square root of 8 is 2.82842..., and since we want to return an integer, the decimal part will be truncated.</div></pre></td></tr></table></figure>
<p>一个数 x 的开方 sqrt 一定在 0 ~ x 之间，并且满足 sqrt == x / sqrt。可以利用二分查找在 0 ~ x 之间查找 sqrt。</p>
<p>对于 x = 8，它的开方是 2.82842…，最后应该返回 2 而不是 3。在循环条件为 l &lt;= h 并且循环退出时，h 总是比 l 小 1，也就是说 h = 2，l = 3，因此最后的返回值应该为 h 而不是 l。</p>
<h4 id="2-大于给定元素的最小元素"><a href="#2-大于给定元素的最小元素" class="headerlink" title="2. 大于给定元素的最小元素"></a>2. 大于给定元素的最小元素</h4><p>给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。</p>
<p>数组里字母的顺序是循环的。举个例子，如果目标字母target = ‘z’ 并且有序数组为 letters = [‘a’, ‘b’]，则答案返回 ‘a’。</p>
<p>题目描述：给定一个有序的字符数组 letters 和一个字符 target，要求找出 letters 中大于 target 的最小字符，如果找不到就返回第 1 个字符（这句话是转换题意）。</p>
<h4 id="3-有序数组的-Single-Element"><a href="#3-有序数组的-Single-Element" class="headerlink" title="3. 有序数组的 Single Element"></a>3. 有序数组的 Single Element</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [1, 1, 2, 3, 3, 4, 4, 8, 8]</div><div class="line">Output: 2</div></pre></td></tr></table></figure>
<p>题目描述：一个有序数组只有一个数不出现两次，找出这个数。</p>
<p>要求以 O(logN) 时间复杂度进行求解，因此不能遍历数组并进行异或操作来求解，这么做的时间复杂度为 O(N)。</p>
<p>令 index 为 Single Element 在数组中的位置。在 index 之后，数组中原来存在的成对状态被改变。如果 m 为偶数，并且 m + 1 &lt; index，那么 nums[m] == nums[m + 1]；m + 1 &gt;= index，那么 nums[m] != nums[m + 1]。</p>
<p>从上面的规律可以知道，如果 nums[m] == nums[m + 1]，那么 index 所在的数组位置为 [m + 2, h]，此时令 l = m + 2；如果 nums[m] != nums[m + 1]，那么 index 所在的数组位置为 [l, m]，此时令 h = m。</p>
<p><strong>因为 h 的赋值表达式为 h = m，那么循环条件也就只能使用 l &lt; h 这种形式。</strong></p>
<h4 id="4-第一个错误的版本"><a href="#4-第一个错误的版本" class="headerlink" title="4. 第一个错误的版本"></a>4. 第一个错误的版本</h4><p>题目描述：给定一个元素 n 代表有 [1, 2, …, n] 版本，在第 x 位置开始出现错误版本，导致后面的版本都错误。可以调用 isBadVersion(int x) 知道某个版本是否错误，要求找到第一个错误的版本。</p>
<p>如果第 m 个版本出错，则表示第一个错误的版本在 [l, m] 之间，令 h = m；否则第一个错误的版本在 [m + 1, h] 之间，令 l = m + 1。</p>
<p><strong>因为 h 的赋值表达式为 h = m，因此循环条件为 l &lt; h。</strong></p>
<h4 id="5-旋转数组的最小数字"><a href="#5-旋转数组的最小数字" class="headerlink" title="5. 旋转数组的最小数字"></a>5. 旋转数组的最小数字</h4><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。</p>
<p>( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</p>
<p>请找出其中最小的元素。</p>
<p>你可以假设数组中不存在重复元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Input: [3,4,5,1,2],</div><div class="line">Output: 1</div></pre></td></tr></table></figure>
<p>思路：二分法 if (nums[m] &lt;= nums[h]) {            h = m; }       l&lt;h</p>
<h4 id="6-查找区间"><a href="#6-查找区间" class="headerlink" title="6. 查找区间"></a>6. 查找区间</h4><p>不弄了，细节是魔鬼。。</p>
<blockquote>
<p>二分查找，正常是l&lt;=h 然后if 三段论，mid+1,mid-1;对于1其实是要向下取整的，所以应该返回l和h当中小的那个即为h；对于h=m的情况，循环条件就用l&lt;h,如：3，4，5；对于5找旋转数组的最小数字的if条件【if (nums[m] &lt;= nums[h]) {】比较巧妙；6看不懂，可以看个链接</p>
<p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/" target="_blank" rel="external">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/er-fen-cha-zhao-suan-fa-xi-jie-xiang-jie-by-labula/</a></p>
</blockquote>
<h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><h4 id="1-生成素数序列"><a href="#1-生成素数序列" class="headerlink" title="1. 生成素数序列"></a>1. 生成素数序列</h4><p>统计所有小于非负整数 n的质数的数量。</p>
<p><strong>示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">输入: 10</div><div class="line">输出: 4</div><div class="line">解释: 小于 10 的质数一共有 4 个, 它们是 2, 3, 5, 7 。</div></pre></td></tr></table></figure>
<p>思路：</p>
<p>埃拉托斯特尼筛法在每次找到一个素数时，将能被素数整除的数排除掉。</p>
<p>2之后的2 <em> 2,2 </em> 3,2 <em> 4….都标记为不是素数，3之后的3 </em> 3,3 <em> 4,3 </em> 5都标记为不是素数…</p>
<h4 id="2-最大公约数"><a href="#2-最大公约数" class="headerlink" title="2. 最大公约数"></a>2. 最大公约数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int gcd(int a, int b) &#123;</div><div class="line">    return b == 0 ? a : gcd(b, a % b);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最小公倍数为两数的乘积除以最大公约数。(记一记)</p>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><h4 id="1-7-进制"><a href="#1-7-进制" class="headerlink" title="1. 7 进制"></a>1. 7 进制</h4><p>给定一个整数，将其转化为7进制，并以字符串形式输出。</p>
<p>思路：  while (num &gt; 0) {        sb.append(num % 7);        num /= 7;    }。</p>
<p>Java 中 static String toString(int num, int radix) 可以将一个整数转换为 radix 进制表示的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public String convertToBase7(int num) &#123;</div><div class="line">    return Integer.toString(num, 7);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2-16-进制"><a href="#2-16-进制" class="headerlink" title="2. 16 进制"></a>2. 16 进制</h4><p>思路：</p>
<p>负数要用它的补码形式。（记一记吧）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">26</div><div class="line"></div><div class="line">Output:</div><div class="line">&quot;1a&quot;</div><div class="line"></div><div class="line">Input:</div><div class="line">-1</div><div class="line"></div><div class="line">Output:</div><div class="line">&quot;ffffffff&quot;</div></pre></td></tr></table></figure>
<p>负数要用它的补码形式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">char</span>[] map = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>, <span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>&#125;;</div><div class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">"0"</span>;</div><div class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">    <span class="keyword">while</span> (num != <span class="number">0</span>) &#123;</div><div class="line">        sb.append(map[num &amp; <span class="number">0b1111</span>]);</div><div class="line">        num &gt;&gt;&gt;= <span class="number">4</span>; <span class="comment">// 因为考虑的是补码形式，因此符号位就不能有特殊的意义，需要使用无符号右移，左边填 0</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> sb.reverse().toString();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="3-26-进制"><a href="#3-26-进制" class="headerlink" title="3. 26 进制"></a>3. 26 进制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1 -&gt; A</div><div class="line">2 -&gt; B</div><div class="line">3 -&gt; C</div><div class="line">...</div><div class="line">26 -&gt; Z</div><div class="line">27 -&gt; AA</div><div class="line">28 -&gt; AB</div></pre></td></tr></table></figure>
<p>因为是从 1 开始计算的，而不是从 0 开始，因此需要对 n 执行 -1 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line">    n--;</div><div class="line">    <span class="keyword">return</span> convertToTitle(n / <span class="number">26</span>) + (<span class="keyword">char</span>) (n % <span class="number">26</span> + <span class="string">'A'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="阶乘"><a href="#阶乘" class="headerlink" title="阶乘"></a>阶乘</h4><h4 id="1-统计阶乘尾部有多少个-0"><a href="#1-统计阶乘尾部有多少个-0" class="headerlink" title="1. 统计阶乘尾部有多少个 0"></a>1. 统计阶乘尾部有多少个 0</h4><p>给定一个整数 <em>n</em>，返回 <em>n</em>! 结果尾数中零的数量。</p>
<p>尾部的 0 由 2 * 5 得来，2 的数量明显多于 5 的数量，因此只要统计有多少个 5 即可。</p>
<p>对于一个数 N，它所包含 5 的个数为：N/5 + N/52 + N/53 + …，其中 N/5 表示不大于 N 的数中 5 的倍数贡献一个 5，N/52表示不大于 N 的数中 52 的倍数再贡献一个 5 …。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public int trailingZeroes(int n) &#123;</div><div class="line">    return n == 0 ? 0 : n / 5 + trailingZeroes(n / 5);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果统计的是 N! 的二进制表示中最低位 1 的位置，只要统计有多少个 2 即可，该题目出自 <a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%95%B0%E5%AD%A6.md#" target="_blank" rel="external">编程之美：2.2</a> 。和求解有多少个 5 一样，2 的个数为 N/2 + N/22 + N/23 + …</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">举个复杂点的例子：</div><div class="line">10！ = [2 （ 2 * 2 ） 5 （ 2 * 3 ）（ 2 * 2 * 2 ）*（ 2 * 5）]</div><div class="line">在 10！这个阶乘数中可以匹配两对 2 * 5 ，所以10！末尾有 2 个 0。可以发现，一个数字进行拆分后 2 的个数肯定是大于 5 的个数的，所以能匹配多少对取决于 5 的个数。（好比现在男女比例悬殊，最多能有多少对异性情侣取决于女生的多少）。</div><div class="line">那么问题又变成了 统计阶乘数里有多少个 5 这个因子。</div><div class="line">需要注意的是，像 25，125 这样的不只含有一个 5 的数字的情况需要考虑进去。比如 n = 15。那么在 15! 中 有 3 个 5 (来自其中的5, 10, 15)， 所以计算 n/5 就可以 。但是比如 n=25，依旧计算 n/5 ，可以得到 5 个5，分别来自其中的5, 10, 15, 20, 25，但是在 25 中其实是包含 2个 5 的，这一点需要注意。</div><div class="line">所以除了计算 n/5 ， 还要计算 n/5/5 , n/5/5/5 , n/5/5/5/5 , ..., n/5/5/5,,,/5直到商为0，然后求和即可。</div><div class="line"></div><div class="line">作者：chen-chen-6</div><div class="line">链接：https://leetcode-cn.com/problems/factorial-trailing-zeroes/solution/tou-ji-qu-qiao-de-suan-fa-ti-by-chen-chen-6/</div></pre></td></tr></table></figure>
<h4 id="字符串加法减法"><a href="#字符串加法减法" class="headerlink" title="字符串加法减法"></a>字符串加法减法</h4><h4 id="1-二进制加法"><a href="#1-二进制加法" class="headerlink" title="1. 二进制加法"></a>1. 二进制加法</h4><p>思路：双指针， while (carry == 1 || i &gt;= 0 || j &gt;= 0) {；有点像链表7 ：链表求和。</p>
<h4 id="2-字符串加法"><a href="#2-字符串加法" class="headerlink" title="2. 字符串加法"></a>2. 字符串加法</h4><p>给定两个字符串形式的非负整数 <code>num1</code> 和<code>num2</code> ，计算它们的和。</p>
<p>思路：双指针， while (carry == 1 || i &gt;= 0 || j &gt;= 0) {；更加像链表7 ：链表求和。</p>
<h4 id="相遇问题"><a href="#相遇问题" class="headerlink" title="相遇问题"></a>相遇问题</h4><h4 id="1-改变数组元素使所有的数组元素都相等"><a href="#1-改变数组元素使所有的数组元素都相等" class="headerlink" title="1. 改变数组元素使所有的数组元素都相等"></a>1. 改变数组元素使所有的数组元素都相等</h4><p>给定一个非空整数数组，找到使所有数组元素相等所需的最小移动数，其中每次移动可将选定的一个元素加1或减1。 您可以假设数组的长度最多为10000。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Input:</div><div class="line">[1,2,3]</div><div class="line"></div><div class="line">Output:</div><div class="line">2</div><div class="line"></div><div class="line">Explanation:</div><div class="line">Only two moves are needed (remember each move increments or decrements one element):</div><div class="line"></div><div class="line">[1,2,3]  =&gt;  [2,2,3]  =&gt;  [2,2,2]</div></pre></td></tr></table></figure>
<p>这是个典型的相遇问题，移动距离最小的方式是所有元素都移动到中位数。</p>
<p>思路：1先排序，再（用首尾指针向中间移动）累加（O(NlogN)。2快速选择找到中位数（如果数组个数为偶数的话其实中间的那2个数都可以作为中位数）O(N)</p>
<h4 id="多数投票问题"><a href="#多数投票问题" class="headerlink" title="多数投票问题"></a>多数投票问题</h4><h4 id="1-数组中出现次数多于-n-2-的元素"><a href="#1-数组中出现次数多于-n-2-的元素" class="headerlink" title="1. 数组中出现次数多于 n / 2 的元素"></a>1. 数组中出现次数多于 n / 2 的元素</h4><p>给定一个大小为 <em>n </em>的数组，找到其中的众数。众数是指在数组中出现次数<strong>大于</strong> <code>⌊ n/2 ⌋</code> 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
<p>思路：1Boyer-Moore Majority Vote Algorithm （没看）2桶排序</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h4 id="1-平方数"><a href="#1-平方数" class="headerlink" title="1. 平方数"></a>1. 平方数</h4><p>给定一个正整数 num，编写一个函数，如果 num 是一个完全平方数，则返回 True，否则返回 False。</p>
<p>说明：不要使用任何内置的库函数，如  sqrt。</p>
<p>思路：1平方序列：1,4,9,16,..间隔：3,5,7,…间隔为等差数列，2自然的思路：i*i = num return true.</p>
<h4 id="2-3-的-n-次方"><a href="#2-3-的-n-次方" class="headerlink" title="2. 3 的 n 次方"></a>2. 3 的 n 次方</h4><p>给定一个整数，写一个函数来判断它是否是 3 的幂次方。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> &amp;&amp; (<span class="number">1162261467</span> % n == <span class="number">0</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="https://tva4.sinaimg.cn/large/005R6Otmgy1g6xxe0qh26j30le0ab0ta.jpg" target="_blank" rel="external">https://tva4.sinaimg.cn/large/005R6Otmgy1g6xxe0qh26j30le0ab0ta.jpg</a></p>
<h4 id="3-乘积数组"><a href="#3-乘积数组" class="headerlink" title="3. 乘积数组"></a>3. 乘积数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">For example, given [1,2,3,4], return [24,12,8,6].</div></pre></td></tr></table></figure>
<p>给定一个数组，创建一个新数组，新数组的每个元素为原始数组中除了该位置上的元素之外所有元素的乘积。</p>
<p>要求时间复杂度为 O(N)，并且不能使用除法。</p>
<p>思路：从左向右一趟循环，从右向左一趟循环，各自得到左边的乘积和右边的乘积</p>
<h4 id="4-找出数组中的乘积最大的三个数"><a href="#4-找出数组中的乘积最大的三个数" class="headerlink" title="4. 找出数组中的乘积最大的三个数"></a>4. 找出数组中的乘积最大的三个数</h4><p>给定一个整型数组，在数组中找出由三个数组成的最大乘积，并输出这个乘积。</p>
<p>思路：我的解法：先排序，再根据正负数个数情况找出最大值；github解法没高兴看。</p>
<blockquote>
<p>每一个数都可以分解成素数的乘积;素数筛法把2之后的2 <em> 2,2 </em> 3,2 <em> 4….都标记为不是素数，3之后的3 </em> 3,3 <em> 4,3 </em> 5都标记为不是素数…；最大公约数 return b == 0 ? a : gcd(b, a % b);最小公倍数为两数的乘积除以最大公约数。………例题都蛮典型的，不总结了。。。</p>
</blockquote>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="1-统计两个数的二进制表示有多少位不同"><a href="#1-统计两个数的二进制表示有多少位不同" class="headerlink" title="1. 统计两个数的二进制表示有多少位不同"></a>1. 统计两个数的二进制表示有多少位不同</h4><p>两个整数之间的<a href="https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB" target="_blank" rel="external">汉明距离</a>指的是这两个数字对应二进制位不同的位置的数目。</p>
<p>给出两个整数 <code>x</code> 和 <code>y</code>，计算它们之间的汉明距离。</p>
<p><strong>注意：</strong><br>0 ≤ <code>x</code>, <code>y</code> &lt; 231.</p>
<p>思路：int z = x ^ y;然后算出z中有几个1。算出几个1的算法有：1 while(z != 0){   if ((z &amp; 1) == 1) cnt++;        z = z &gt;&gt; 1};2 while (z != 0) {        <strong>z &amp;= (z - 1)</strong>;        cnt++;    }；【<code>n&amp;(n-1) 去除 n 的位级表示中最低的那一位。</code>】3Integer.bitCount(z);</p>
<h4 id="2-数组中唯一一个不重复的元素"><a href="#2-数组中唯一一个不重复的元素" class="headerlink" title="2. 数组中唯一一个不重复的元素"></a>2. 数组中唯一一个不重复的元素</h4><p>异或</p>
<h4 id="3-找出数组中缺失的那个数"><a href="#3-找出数组中缺失的那个数" class="headerlink" title="3. 找出数组中缺失的那个数"></a>3. 找出数组中缺失的那个数</h4><p>思路：示例：0,1,3和0,1,2,3异或就能取到2；</p>
<h4 id="4-数组中不重复的两个元素"><a href="#4-数组中不重复的两个元素" class="headerlink" title="4. 数组中不重复的两个元素"></a>4. 数组中不重复的两个元素</h4><p>异或基础上用<strong>diff &amp;= -diff</strong>区分出两个元素第一个不同的位；然后for循环遍历^=;【<code>n&amp;(-n) 得到 n 的位级表示中最低的那一位。</code> 其余位变成0】</p>
<h4 id="5-翻转一个数的比特位"><a href="#5-翻转一个数的比特位" class="headerlink" title="5. 翻转一个数的比特位"></a>5. 翻转一个数的比特位</h4><p>颠倒给定的 32 位无符号整数的二进制位。</p>
<p> 思路</p>
<ol>
<li>将给定的二进制数,由低到高位逐个取出</li>
<li>然后通过位运算将其放置到反转后的位置.</li>
<li>将上述结果再次通过运算结合到一起</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">reverseBits1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">32</span>; i++) &#123;</div><div class="line">            <span class="comment">// 1. 将给定的二进制数,由低到高位逐个取出</span></div><div class="line">            <span class="comment">// 1.1 右移 i 位,</span></div><div class="line">            <span class="keyword">int</span> tmp = n &gt;&gt; i;</div><div class="line">            <span class="comment">// 1.2  取有效位</span></div><div class="line">            tmp = tmp &amp; <span class="number">1</span>;</div><div class="line">            <span class="comment">// 2. 然后通过位运算将其放置到反转后的位置.</span></div><div class="line">            tmp = tmp &lt;&lt; (<span class="number">31</span> - i);</div><div class="line">            <span class="comment">// 3. 将上述结果再次通过运算结合到一起</span></div><div class="line">            result |= tmp;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h4 id="6-不用额外变量交换两个整数"><a href="#6-不用额外变量交换两个整数" class="headerlink" title="6. 不用额外变量交换两个整数"></a>6. 不用额外变量交换两个整数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">a = a ^ b;</div><div class="line">b = a ^ b;</div><div class="line">a = a ^ b;</div></pre></td></tr></table></figure>
<h4 id="7-判断一个数是不是-2-的-n-次方"><a href="#7-判断一个数是不是-2-的-n-次方" class="headerlink" title="7. 判断一个数是不是 2 的 n 次方"></a>7. 判断一个数是不是 2 的 n 次方</h4><p>思路：1二进制表示只有一个 1 存在。【 return n &gt; 0 &amp;&amp; Integer.bitCount(n) == 1;】2利用 1000 &amp; 0111 == 0 这种性质【return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;】</p>
<h4 id="8-判断一个数是不是-4-的-n-次方"><a href="#8-判断一个数是不是-4-的-n-次方" class="headerlink" title="8. 判断一个数是不是 4 的 n 次方"></a>8. 判断一个数是不是 4 的 n 次方</h4><p>思路：1这种数在二进制表示中有且只有一个奇数位为 1，例如 16（10000）。【return num &gt; 0 &amp;&amp; (num &amp; (num - 1)) == 0 &amp;&amp; (num &amp; 0b01010101010101010101010101010101) != 0;】2使用正则表达式进行匹配【return Integer.toString(num, 4).matches(“10*”);】</p>
<p>【public static String toString(int i, int radix)//<code>radix</code> 为进制】</p>
<h4 id="9-判断一个数的位级表示是否不会出现连续的-0-和-1"><a href="#9-判断一个数的位级表示是否不会出现连续的-0-和-1" class="headerlink" title="9. 判断一个数的位级表示是否不会出现连续的 0 和 1"></a>9. 判断一个数的位级表示是否不会出现连续的 0 和 1</h4><p>给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。</p>
<p>示例 1:</p>
<p>输入: 5<br>输出: True<br>解释:<br>5的二进制数是: 101</p>
<p>思路：对于 1010 这种位级表示的数，把它向右移动 1 位得到 101，这两个数每个位都不同，因此异或得到的结果为 1111。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAlternatingBits</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> a = (n ^ (n &gt;&gt; <span class="number">1</span>));</div><div class="line">    <span class="keyword">return</span> (a &amp; (a + <span class="number">1</span>)) == <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="10-求一个数的补码"><a href="#10-求一个数的补码" class="headerlink" title="10. 求一个数的补码"></a>10. 求一个数的补码</h4><p>给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。</p>
<p>题目描述：不考虑二进制表示中的首 0 部分。</p>
<p>对于 00000101，要求补码可以将它与 00000111 进行异或操作。那么问题就转换为求掩码 00000111。</p>
<p>可以利用 Java 的 Integer.highestOneBit() 方法来获得含有首 1 的数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findComplement</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (num == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">int</span> mask = Integer.highestOneBit(num);<span class="comment">//例如Integer.highestOneBit(11)等于8</span></div><div class="line">    mask = (mask &lt;&lt; <span class="number">1</span>) - <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> num ^ mask;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="11-实现整数的加法"><a href="#11-实现整数的加法" class="headerlink" title="11. 实现整数的加法"></a>11. 实现整数的加法</h4><p><strong>a ^ b 表示没有考虑进位的情况下两数的和，(a &amp; b) &lt;&lt; 1 就是进位。</strong></p>
<p>递归会终止的原因是 (a &amp; b) &lt;&lt; 1 最右边会多一个 0，那么继续递归，进位最右边的 0 会慢慢增多，最后进位会变为 0，递归终止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : getSum((a ^ b), (a &amp; b) &lt;&lt; <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="12-字符串数组最大乘积"><a href="#12-字符串数组最大乘积" class="headerlink" title="12. 字符串数组最大乘积"></a>12. 字符串数组最大乘积</h4><p>给定一个字符串数组 words，找到 length(word[i]) * length(word[j]) 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p>
<p>思路：1.暴力2.本题主要问题是判断两个字符串是否含相同字符，由于字符串只含有小写字符，总共 26 位，因此可以用一个 32 位的整数来存储每个字符是否出现过。【例如int[] val = new int[n];中val[0]=11的话就代表1011就代表a,b,d已经出现过了】</p>
<h4 id="13-统计从-0-n-每个数的二进制表示中-1-的个数"><a href="#13-统计从-0-n-每个数的二进制表示中-1-的个数" class="headerlink" title="13. 统计从 0 ~ n 每个数的二进制表示中 1 的个数"></a>13. 统计从 0 ~ n 每个数的二进制表示中 1 的个数</h4><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num </strong>范围中的每个数字 <strong>i </strong>，计算其二进制数中的 1 的数目并将它们作为数组返回。</p>
<p>思路:1.Integer.bitCount;2对于数字 6(110)，它可以看成是 4(100) 再加一个 2(10)，因此 dp[i] = dp[i&amp;(i-1)] + 1;</p>
<blockquote>
<p>n&amp;(n-1) 去除 n 的位级表示中最低的那一位。</p>
<p>n&amp;(-n) 得到 n 的位级表示中最低的那一位。</p>
<p>n-n&amp;(~n+1) 去除 n 的位级表示中最高的那一位。</p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/05/08/spark性能调优/" rel="next" title="spark性能调优">
                <i class="fa fa-chevron-left"></i> spark性能调优
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/15/LeetCode刷题目录2/" rel="prev" title="LeetCode刷题目录2">
                LeetCode刷题目录2 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        <!-- JiaThis Button BEGIN -->
<div class="jiathis_style">
<span class="jiathis_txt">分享到：</span>
<a class="jiathis_button_fav">收藏夹</a>
<a class="jiathis_button_copy">复制网址</a>
<a class="jiathis_button_email">邮件</a>
<a class="jiathis_button_weixin">微信</a>
<a class="jiathis_button_qzone">QQ空间</a>
<a class="jiathis_button_tqq">腾讯微博</a>
<a class="jiathis_button_douban">豆瓣</a>
<a class="jiathis_button_share">一键分享</a>

<a href="http://www.jiathis.com/share?uid=2140465" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
<a class="jiathis_counter_style"></a>
</div>
<script type="text/javascript" >
var jiathis_config={
  data_track_clickback:true,
  summary:"",
  shortUrl:false,
  hideMore:false
}
</script>
<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=" charset="utf-8"></script>
<!-- JiaThis Button END -->
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC8zMzQ4OS8xMDA0NQ"></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars3.githubusercontent.com/u/14857317?s=460&v=4"
                alt="陈海涛" />
            
              <p class="site-author-name" itemprop="name">陈海涛</p>
              <p class="site-description motion-element" itemprop="description">You can call me Susan if it makes you happy</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#链表"><span class="nav-number">1.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-找出两个链表的交点"><span class="nav-number">1.1.</span> <span class="nav-text">1. 找出两个链表的交点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-链表反转"><span class="nav-number">1.2.</span> <span class="nav-text">2. 链表反转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-归并两个有序的链表"><span class="nav-number">1.3.</span> <span class="nav-text">3. 归并两个有序的链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-从有序链表中删除重复节点"><span class="nav-number">1.4.</span> <span class="nav-text">4. 从有序链表中删除重复节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-删除链表的倒数第-n-个节点"><span class="nav-number">1.5.</span> <span class="nav-text">5. 删除链表的倒数第 n 个节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-交换链表中的相邻结点"><span class="nav-number">1.6.</span> <span class="nav-text">6. 交换链表中的相邻结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-链表求和"><span class="nav-number">1.7.</span> <span class="nav-text">7. 链表求和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-回文链表"><span class="nav-number">1.8.</span> <span class="nav-text">8. 回文链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-分隔链表"><span class="nav-number">1.9.</span> <span class="nav-text">9. 分隔链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-链表元素按奇偶聚集"><span class="nav-number">1.10.</span> <span class="nav-text">10. 链表元素按奇偶聚集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双指针"><span class="nav-number">2.</span> <span class="nav-text">双指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-有序数组的-Two-Sum"><span class="nav-number">2.1.</span> <span class="nav-text">1. 有序数组的 Two Sum</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-两数平方和"><span class="nav-number">2.2.</span> <span class="nav-text">2. 两数平方和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-反转字符串中的元音字符"><span class="nav-number">2.3.</span> <span class="nav-text">3. 反转字符串中的元音字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-回文字符串"><span class="nav-number">2.4.</span> <span class="nav-text">4. 回文字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-归并两个有序数组"><span class="nav-number">2.5.</span> <span class="nav-text">5. 归并两个有序数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-判断链表是否存在环"><span class="nav-number">2.6.</span> <span class="nav-text">6. 判断链表是否存在环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-最长子序列"><span class="nav-number">2.7.</span> <span class="nav-text">7. 最长子序列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组与矩阵"><span class="nav-number">3.</span> <span class="nav-text">数组与矩阵</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-把数组中的-0-移到末尾"><span class="nav-number">3.1.</span> <span class="nav-text">1. 把数组中的 0 移到末尾</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-改变矩阵维度"><span class="nav-number">3.2.</span> <span class="nav-text">2. 改变矩阵维度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-找出数组中最长的连续-1"><span class="nav-number">3.3.</span> <span class="nav-text">3. 找出数组中最长的连续 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-有序矩阵查找"><span class="nav-number">3.4.</span> <span class="nav-text">4. 有序矩阵查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-有序矩阵的-Kth-Element"><span class="nav-number">3.5.</span> <span class="nav-text">5. 有序矩阵的 Kth Element</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-一个数组元素在-1-n-之间，其中一个数被替换为另一个数，找出重复的数和丢失的数"><span class="nav-number">3.6.</span> <span class="nav-text">6. 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1寻找所有丢失的元素"><span class="nav-number">3.7.</span> <span class="nav-text">6.1寻找所有丢失的元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2寻找所有重复的元素-同上思路"><span class="nav-number">3.8.</span> <span class="nav-text">6.2寻找所有重复的元素(同上思路)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-找出数组中重复的数，数组值在-1-n-之间"><span class="nav-number">3.9.</span> <span class="nav-text">7. 找出数组中重复的数，数组值在 [1, n] 之间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-数组相邻差值的个数"><span class="nav-number">3.10.</span> <span class="nav-text">8. 数组相邻差值的个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-数组的度"><span class="nav-number">3.11.</span> <span class="nav-text">9. 数组的度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-对角元素相等的矩阵"><span class="nav-number">3.12.</span> <span class="nav-text">10. 对角元素相等的矩阵</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-嵌套数组"><span class="nav-number">3.13.</span> <span class="nav-text">11. 嵌套数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-分隔数组"><span class="nav-number">3.14.</span> <span class="nav-text">12. 分隔数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串"><span class="nav-number">4.</span> <span class="nav-text">字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-字符串循环移位包含"><span class="nav-number">4.1.</span> <span class="nav-text">1. 字符串循环移位包含</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-字符串循环移位"><span class="nav-number">4.2.</span> <span class="nav-text">2. 字符串循环移位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-字符串中单词的翻转"><span class="nav-number">4.3.</span> <span class="nav-text">3. 字符串中单词的翻转</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-两个字符串包含的字符是否完全相同"><span class="nav-number">4.4.</span> <span class="nav-text">4. 两个字符串包含的字符是否完全相同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-计算一组字符集合可以组成的回文字符串的最大长度"><span class="nav-number">4.5.</span> <span class="nav-text">5. 计算一组字符集合可以组成的回文字符串的最大长度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-字符串同构"><span class="nav-number">4.6.</span> <span class="nav-text">6. 字符串同构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-回文子字符串个数"><span class="nav-number">4.7.</span> <span class="nav-text">7. 回文子字符串个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-判断一个整数是否是回文数"><span class="nav-number">4.8.</span> <span class="nav-text">8. 判断一个整数是否是回文数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-统计二进制字符串中连续-1-和连续-0-数量相同的子字符串个数"><span class="nav-number">4.9.</span> <span class="nav-text">9. 统计二进制字符串中连续 1 和连续 0 数量相同的子字符串个数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#哈希表"><span class="nav-number">5.</span> <span class="nav-text">哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数组中两个数的和为给定值"><span class="nav-number">5.1.</span> <span class="nav-text">1. 数组中两个数的和为给定值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-判断数组是否含有重复元素"><span class="nav-number">5.2.</span> <span class="nav-text">2. 判断数组是否含有重复元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-最长和谐序列"><span class="nav-number">5.3.</span> <span class="nav-text">3. 最长和谐序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-最长连续序列"><span class="nav-number">5.4.</span> <span class="nav-text">4. 最长连续序列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#栈和队列"><span class="nav-number">6.</span> <span class="nav-text">栈和队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-用栈实现队列"><span class="nav-number">6.1.</span> <span class="nav-text">1. 用栈实现队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-用队列实现栈"><span class="nav-number">6.2.</span> <span class="nav-text">2. 用队列实现栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-最小值栈"><span class="nav-number">6.3.</span> <span class="nav-text">3. 最小值栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-用栈实现括号匹配"><span class="nav-number">6.4.</span> <span class="nav-text">4.用栈实现括号匹配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-数组中元素与下一个比它大的元素之间的距离"><span class="nav-number">6.5.</span> <span class="nav-text">5. 数组中元素与下一个比它大的元素之间的距离</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-循环数组中比当前元素大的下一个元素"><span class="nav-number">6.6.</span> <span class="nav-text">6. 循环数组中比当前元素大的下一个元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序"><span class="nav-number">7.</span> <span class="nav-text">排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Kth-Element"><span class="nav-number">7.1.</span> <span class="nav-text">1. Kth Element</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#桶排序"><span class="nav-number">7.2.</span> <span class="nav-text">桶排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-出现频率最多的-k-个元素"><span class="nav-number">7.3.</span> <span class="nav-text">1. 出现频率最多的 k 个元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-按照字符出现次数对字符串排序"><span class="nav-number">7.4.</span> <span class="nav-text">2. 按照字符出现次数对字符串排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#荷兰国旗问题"><span class="nav-number">7.5.</span> <span class="nav-text">荷兰国旗问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二分查找"><span class="nav-number">8.</span> <span class="nav-text">二分查找</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-求开方"><span class="nav-number">8.1.</span> <span class="nav-text">1. 求开方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-大于给定元素的最小元素"><span class="nav-number">8.2.</span> <span class="nav-text">2. 大于给定元素的最小元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-有序数组的-Single-Element"><span class="nav-number">8.3.</span> <span class="nav-text">3. 有序数组的 Single Element</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-第一个错误的版本"><span class="nav-number">8.4.</span> <span class="nav-text">4. 第一个错误的版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-旋转数组的最小数字"><span class="nav-number">8.5.</span> <span class="nav-text">5. 旋转数组的最小数字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-查找区间"><span class="nav-number">8.6.</span> <span class="nav-text">6. 查找区间</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数学"><span class="nav-number">9.</span> <span class="nav-text">数学</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-生成素数序列"><span class="nav-number">9.1.</span> <span class="nav-text">1. 生成素数序列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-最大公约数"><span class="nav-number">9.2.</span> <span class="nav-text">2. 最大公约数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进制转换"><span class="nav-number">9.3.</span> <span class="nav-text">进制转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-进制"><span class="nav-number">9.4.</span> <span class="nav-text">1. 7 进制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-16-进制"><span class="nav-number">9.5.</span> <span class="nav-text">2. 16 进制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-26-进制"><span class="nav-number">9.6.</span> <span class="nav-text">3. 26 进制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#阶乘"><span class="nav-number">9.7.</span> <span class="nav-text">阶乘</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-统计阶乘尾部有多少个-0"><span class="nav-number">9.8.</span> <span class="nav-text">1. 统计阶乘尾部有多少个 0</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串加法减法"><span class="nav-number">9.9.</span> <span class="nav-text">字符串加法减法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-二进制加法"><span class="nav-number">9.10.</span> <span class="nav-text">1. 二进制加法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-字符串加法"><span class="nav-number">9.11.</span> <span class="nav-text">2. 字符串加法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#相遇问题"><span class="nav-number">9.12.</span> <span class="nav-text">相遇问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-改变数组元素使所有的数组元素都相等"><span class="nav-number">9.13.</span> <span class="nav-text">1. 改变数组元素使所有的数组元素都相等</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#多数投票问题"><span class="nav-number">9.14.</span> <span class="nav-text">多数投票问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数组中出现次数多于-n-2-的元素"><span class="nav-number">9.15.</span> <span class="nav-text">1. 数组中出现次数多于 n / 2 的元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他"><span class="nav-number">9.16.</span> <span class="nav-text">其他</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-平方数"><span class="nav-number">9.17.</span> <span class="nav-text">1. 平方数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-的-n-次方"><span class="nav-number">9.18.</span> <span class="nav-text">2. 3 的 n 次方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-乘积数组"><span class="nav-number">9.19.</span> <span class="nav-text">3. 乘积数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-找出数组中的乘积最大的三个数"><span class="nav-number">9.20.</span> <span class="nav-text">4. 找出数组中的乘积最大的三个数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位运算"><span class="nav-number">10.</span> <span class="nav-text">位运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-统计两个数的二进制表示有多少位不同"><span class="nav-number">10.1.</span> <span class="nav-text">1. 统计两个数的二进制表示有多少位不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-数组中唯一一个不重复的元素"><span class="nav-number">10.2.</span> <span class="nav-text">2. 数组中唯一一个不重复的元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-找出数组中缺失的那个数"><span class="nav-number">10.3.</span> <span class="nav-text">3. 找出数组中缺失的那个数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-数组中不重复的两个元素"><span class="nav-number">10.4.</span> <span class="nav-text">4. 数组中不重复的两个元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-翻转一个数的比特位"><span class="nav-number">10.5.</span> <span class="nav-text">5. 翻转一个数的比特位</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-不用额外变量交换两个整数"><span class="nav-number">10.6.</span> <span class="nav-text">6. 不用额外变量交换两个整数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-判断一个数是不是-2-的-n-次方"><span class="nav-number">10.7.</span> <span class="nav-text">7. 判断一个数是不是 2 的 n 次方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-判断一个数是不是-4-的-n-次方"><span class="nav-number">10.8.</span> <span class="nav-text">8. 判断一个数是不是 4 的 n 次方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-判断一个数的位级表示是否不会出现连续的-0-和-1"><span class="nav-number">10.9.</span> <span class="nav-text">9. 判断一个数的位级表示是否不会出现连续的 0 和 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-求一个数的补码"><span class="nav-number">10.10.</span> <span class="nav-text">10. 求一个数的补码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-实现整数的加法"><span class="nav-number">10.11.</span> <span class="nav-text">11. 实现整数的加法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-字符串数组最大乘积"><span class="nav-number">10.12.</span> <span class="nav-text">12. 字符串数组最大乘积</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-统计从-0-n-每个数的二进制表示中-1-的个数"><span class="nav-number">10.13.</span> <span class="nav-text">13. 统计从 0 ~ n 每个数的二进制表示中 1 的个数</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈海涛</span>

  
</div>


  <div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
  本站访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>
  <!--<div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>-->



  <span class="post-meta-divider">|</span>


<!--
  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>
-->


<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共37.9k字</span>
</div>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  
    <script type="text/javascript">
      (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
      })(document, 'script');
    </script>
  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  

  

  

  
   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>

</body>
</html>
